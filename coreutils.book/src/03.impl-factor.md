# 实现 factor

factor 的作用是：从命令行读取数字，分解质因数并打印在 stdout。可以同时传入多个数字，将每个数字分别分解并打印。

```
$ factor 123 321
123: 3 41
321: 3 107
```

## 解析命令行参数

除了和 [yes](./02.impl-yes.md) 相同的部分之外，这里介绍一下 `validator`。

顾名思义，`validator` 是用于检验参数的，它需要一个函数或闭包，接受 `String` 类型的参数，输出 `Result<(), String>`。当输出为 `Ok(())` 时，表明该参数通过检验，当输出为 `Err(String)` 时，表示该参数不能通过检验，并提供错误信息。

```rust,ignore
fn(String) -> Result<(), String>
```

我们在这里检验的目的是，确定输入的参数是数字，如果不是数字，则记录下来，之后一次性报错。为什么不一遇到非数字就报错呢？虽然一遇到就报错在编写时非常方便，但在使用时，遇到那种有多个错误的情况，就非常恶心，可能要尝试几次才能把所有错误都找出来，尤其是当输入特别长的情况下。在这个检测器中，我们使用一个 `std::collection::BTreeSet<usize>` 来存储出错的字符在参数中所处于的位置，之所以不使用 `Vec<usize>`，是因为二叉树的搜索比线性表更快。

```rust,ignore
{{#include ../../factor/src/main.rs:validator}}
```

在报错时，validator 会在 stderr 中打印这样的字符串：

```
error: Invalid value for '<NUMBER>...': {'a', 'b', 'c'}
```

对于设置了 `.multiple` 的参数，`validator` 函数会对每个都分别执行检测函数。为了在多个参数中寻找错误的字符，并且自定义报错样式，我令 validator 的返回值都为 `Ok(())`，然后在所有命令行参数都解析完了之后再根据错误收集器中的内容进行报错。

为了实现此目标，我们需要一个具有静态声明周期的收集器，Rust 的 static 变量必须在定义时通过 const fn 初始化，恰好 `Vec::new()` 是一个 const fn，因此，可以这样定义一个错误信息的收集器：

```rust,ignore
static mut ERROR_COLLECTOR: Vec<String> = Vec::new();
```

为了让 validator 检测每一个传入的参数，而非检测到一个错误的参数后就停止运行，那么 validator 就返回 Ok，而将是否终止程序的判断放在 main 函数中：

```rust,ignore
fn main() {
    // 解析命令行参数

{{#include ../../factor/src/main.rs:true_validate}}

    // 如果检测通过，则继续运行
}
```
